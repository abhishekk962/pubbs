{% extends "dashboard.html" %}
{% block head %}
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" crossorigin="anonymous"></script>
{% endblock %}
{% block content %}
<script>var tab = $( "button:contains('Live')" ).attr('disabled','');</script>
  <div class="mapdata">
    <div id="route-bar"></div>
    {% if message %}<div id="messagebox">{{message}}</div>{% endif %}
    <div id="map"></div>
    <div class="maptable">
      <div></div>
      <div></div>
      <div></div>
    </div>
  </div>
  <p style="position:fixed;opacity:0;" id="username">{{ session['email'] }}</p>
{% endblock %}
{% block foot %}
  <script src="https://cdn.jsdelivr.net/npm/leaflet@1.7.1/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>
  <script>
    var busMarker = {
        radius : 10,
        color  : '#125482',
        opacity: 1,
        stroke : false,
        fillOpacity: 1,
        weight:5,
        fillcolor:'#ff0000',
    }

    var stopMarker = {
        radius : 10,
        color  : '#ff0000',
        opacity: 1,
        stroke : false,
        fillOpacity: 1,
        weight:5,
        fillcolor:'#ff0000',
    }

    var map = L.map('map').setView([51.505, -0.09], 13);

    L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
      subdomains: 'abcd',
      maxZoom: 20
    }).addTo(map);
    
    // Search box
    var searchControl = L.Control.geocoder({
      defaultMarkGeocode: false,
      placeholder: 'Search location...',
      errorMessage: 'No results found.',
      showResultIcons: true,
      collapsed: false,
    }).on('markgeocode', function (e) {
      map.setView(e.geocode.center, 13);
      addMarker(e.geocode.center);
    }).addTo(map);

    // For clearing search results
    document.querySelector('div.leaflet-top.leaflet-right > div > ul').addEventListener('click', function () {
        searchControl._clearResults()
    })
    document.querySelector('#map').addEventListener('click', function () {
        searchControl._clearResults()
    })


    var linesLayer = L.layerGroup().addTo(map);
    var clickedmarkers = L.layerGroup().addTo(map);
    var markersLayer = L.layerGroup().addTo(map);

    var markerCount = 0;

    var markersarray = [];
    var polyline = null;

    var latitudes = []
    var longitudes = []

    // Fetch data from Flask endpoint
    fetch('/route-data')
      .then(response => response.json())
      .then(data => {
        // Loop through the data and add markers
        data.forEach(point => {
          var marker = L.circleMarker([point.lat, point.lng],busMarker).addTo(markersLayer);
          marker.bindTooltip(point.name, {permanent: true, className: "my-label", offset: [0, 0] });
          marker.bindPopup(point.name);
          marker.key = point.id;
          marker._path.style.filter = "hue-rotate(120deg)"
          latitudes.push(point.lat);
          longitudes.push(point.lng);
          markersarray.push(marker);
        });
        if (markersarray.length > 1) {
          var latlngs = markersarray.map(function(marker) {
            return marker.getLatLng();
          });
          // Remove the previous polyline if it exists
          if (polyline) {
            linesLayer.removeLayer(polyline);
          }
          var polyline = L.polyline(latlngs, { color: '#3388ff', weight: 20 , opacity: 0.1}).bringToBack().addTo(linesLayer);
        }
        map.setView([latitudes[0], longitudes[0]],15);
      })
      .catch(error => {
        console.error('Error:', error);
      });

      // livelocation
      var email = document.getElementById('username').textContent;

      var socket = io();
      socket.on('connect', function() {
          socket.emit('join',{room: email});
          socket.emit('my event', {data: 'I\'m connected!'});
      });

      map.on('click', function(e) {
        socket.emit('location', {latitude: e.latlng.lat, longitude: e.latlng.lng})
      });

      var prevstop = markersarray[0];
      var nextstop = markersarray[1];

      var coord2 = null;
      var coord1 = null;
      var coord0 = null;

      var prevCoord = null;

      var busLayer = L.layerGroup().addTo(map);

      pollInterval = setInterval(function() { // run function every 2000 ms
          refreshPings();
        }, 2000);

      refreshPings();

      function refreshPings() {
          $.ajax({
            url: '/get-pings',
            dataType: 'json',
            type: 'get',
            success: function(data) { // check if available
              if ( data ) { // get and check data value
                console.log(data);
                processPing(data); // get and print data string
              }
            },
            error: function() { // error logging
              console.log('Error!');
            }
          });
        };

      function processPing(data) {
        // Clear bus location
        busLayer.clearLayers();

        // Show previous 3 coordinates on page
        var threeCoord = document.querySelectorAll('.maptable > div');
        threeCoord[2].innerHTML = data[2]['latitude'] + ' , ' + data[2]['longitude'];
        threeCoord[1].innerHTML = data[1]['latitude'] + ' , ' + data[1]['longitude'];
        threeCoord[0].innerHTML = data[0]['latitude'] + ' , ' + data[0]['longitude'];

        // Save previous threee coordinates
        coord2 = [data[2]['latitude'],data[2]['longitude']];
        coord1 = [data[1]['latitude'],data[1]['longitude']];
        coord0 = [data[0]['latitude'],data[0]['longitude']];

        var timediff = data[0]['Timediff']
        var speed = data[0]['Speed']
        console.log(timediff,speed)

        // Get the average of the coordinates and create a pointer at the location
        // currCoord = [(coord2[0]+coord1[0]+coord0[0])/3,(coord2[1]+coord1[1]+coord0[1])/3];
        var currCoord = [coord0[0],coord0[1]];
        var pointer = L.marker(currCoord);

        // // Save the perpendicular distance of pointer from each segment
        // var distances = []
        // for (let i = 0; i < markersarray.length - 1; i++) {
        //   var proj = calculateProjection(markersarray[i].getLatLng(),markersarray[i+1].getLatLng(),pointer.getLatLng());
        //   var projMarker = L.circleMarker([proj.x,proj.y])
        //   distances.push(distBet(projMarker,pointer));
        // }
        
        var distances = []
        markersarray.forEach(marker => {
          distances.push(distBet(marker,pointer));
        })
        
        // Based on perpendicular distance from segment, determine previous and next stop
        var closestStop = getClosestStop(distances, markersarray);

        // Three sides of trianble joining nearest stop, prev stop and next stop
        var side1 = distBet(pointer,closestStop)
        var side2 = distBet(closestStop,markersarray[markersarray.indexOf(closestStop)+1])
        var side3 = distBet(markersarray[markersarray.indexOf(closestStop)+1],pointer)

        //If triangle is obtuse, previous stop is the one before closest stop
        if (side3**2 > side2**2+side1**2){
          prevstop = markersarray[markersarray.indexOf(closestStop) - 1]
        } else {
          prevstop = closestStop
        }


        // var prevClose = markersarray[markersarray.indexOf(closestStop) - 1]
        // var prevCloseProj = calculateProjection(closestStop.getLatLng(),prevClose.getLatLng(),pointer.getLatLng());
        // var prevProjMarker = L.circleMarker([prevCloseProj.x,prevCloseProj.y])
        
        // var nextClose = markersarray[markersarray.indexOf(closestStop) + 1]
        // var nextCloseProj = calculateProjection(closestStop.getLatLng(),nextClose.getLatLng(),pointer.getLatLng());
        // var nextProjMarker = L.circleMarker([nextCloseProj.x,nextCloseProj.y])

        // if (distBet(prevProjMarker,pointer) < distBet(nextProjMarker,pointer)) {
        //   prevstop = markersarray[markersarray.indexOf(closestStop) - 1]
        // } else {
        //   prevstop = closestStop
        // }

        nextstop = markersarray[markersarray.indexOf(prevstop)+1]

        
        // If the ping location is close to a stop, the previous and next stops will change
        for (let i = 0; i < markersarray.length; i++) {
          if (distBet(markersarray[i],pointer) < 0.00005) {
            prevstop = markersarray[i]
            nextstop = markersarray[markersarray.indexOf(prevstop)+1]
            break
          }
        }

        // If the pointer's distance from previous stop is more than the segment length, move to next segment
        if (distBet(prevstop,pointer) > distBet(prevstop,nextstop)) {
          prevstop = nextstop
          nextstop = markersarray[markersarray.indexOf(prevstop)+1]
        }

        // Show previous and next stops
        prevstop._path.style.filter = "grayscale(1)";
        prevstop.addTo(map);
        nextstop._path.style.filter = "sepia(1)";
        nextstop.addTo(map);
        
        // Get the location of pointer prjected on final segment
        var proj = calculateProjection(prevstop.getLatLng(),nextstop.getLatLng(),pointer.getLatLng());
        var projMarker = L.circleMarker([proj.x,proj.y],busMarker)
        
        // If the pointer's distance from next stop is more than segment length, bus will be at the previous stop
        if (distBet(projMarker,nextstop) > distBet(prevstop,nextstop)) {
          projMarker = L.circleMarker([prevstop.getLatLng().lat,prevstop.getLatLng().lng],busMarker)
        }

        projMarker.addTo(busLayer);

        var segments = []
        var totalDist = 0
        for (let i = 0; i < markersarray.length-1; i++) {
          var dist = distBet(markersarray[i],markersarray[i+1])
          segments.push(dist);
          totalDist = totalDist + dist
        };

        document.getElementById('route-bar').replaceChildren()
        
        segments.forEach(segment => {
          var segElem = document.createElement('div')
          segElem.classList.add('route-segment')
          segElem.style.width = segment*100/totalDist + '%'
          var stopElem = document.createElement('div')
          stopElem.classList.add('route-marker')
          segElem.appendChild(stopElem)
          document.getElementById('route-bar').appendChild(segElem)
        });
        var segElem = document.createElement('div')
        segElem.classList.add('route-segment')
        segElem.style.width = '0%'
        var stopElem = document.createElement('div')
        stopElem.classList.add('route-marker')
        segElem.appendChild(stopElem)
        document.getElementById('route-bar').appendChild(segElem)

        var covDist = 0;
        for (let i = 0; i <= markersarray.indexOf(prevstop); i++) {
          covDist = covDist + distBet(markersarray[i],markersarray[i+1])
        };
        covDist = covDist + distBet(prevstop,projMarker);

        var busElem = document.createElement('div')
        busElem.classList.add('route-bus')
        busElem.style.width = covDist*100/totalDist + '%'
        var busLocElem = document.createElement('div')
        busLocElem.classList.add('route-marker')
        busLocElem.style.scale = 1.2
        busLocElem.style.right = 0
        busLocElem.style.margin = '0 -5px 0 0'
        busElem.appendChild(busLocElem)
        document.getElementById('route-bar').appendChild(busElem)

        prevCoord = projMarker;
      };

      function distBet(marker1,marker2) {
        let lat1 = marker1.getLatLng().lat
        let lng1 = marker1.getLatLng().lng
        let lat2 = marker2.getLatLng().lat
        let lng2 = marker2.getLatLng().lng
        
        let deltalat = lat1 - lat2
        let deltalng = lng1 - lng2
        let distance = Math.sqrt(deltalat ** 2 + deltalng ** 2);
        return distance
      }


      function getClosestStop(distances, stops) {
        // Find the index of the minimum value in distances
        let minIndex = 0;
        for (let i = 1; i < distances.length; i++) {
          if (distances[i] < distances[minIndex]) {
            minIndex = i;
          }
        }

        const closestStop = stops[minIndex];

        return closestStop;
      }

      function calculateProjection(A, B, X) {
        const AB = { lat: B.lat - A.lat, lng: B.lng - A.lng };
        const AX = { lat: X.lat - A.lat, lng: X.lng - A.lng };
        const dotProduct = AX.lat * AB.lat + AX.lng * AB.lng;
        const lengthABSquared = AB.lat * AB.lat + AB.lng * AB.lng;
        const scalarProjection = dotProduct / lengthABSquared;
        const P = {
          x: A.lat + scalarProjection * AB.lat,
          y: A.lng + scalarProjection * AB.lng,
        };
        return P;
      }
  </script>
{% endblock %}